---
title: "FSOP attack - (1)"
date : 2025-12-04 19:00:00
categoris: [Pwnable, Heap, FSOP]
tags : [fsop , pwn , glibc , file-structure]
---


## FSOP
===Part 1=== FIle Structure Analyze

[Part 2 : How to use for attack]


##개요 


FILE은 리눅스 시스템의 표준 IO 라이브러리에서 파일 스트림을 설명하는 구조체로 파일이나 기타 I/O리소스에 대한 입출력 작업을 수행하는데 필요한 정보를 담고있다. 

FILE구조체는 프로그램이 fopen과 같은 함수를 실행할떄 생성되어 힙에 할당된다. 이 반환값을 받기 위해 FILE 구조체에 대한 포인터를 정의하는 경우가 많다.

*표준 입출력의 계층 구조

```
Application Layer
          ↓
Standard I/O Library (stdio) - Buffered I/O

  (fopen, fread, fwrite, fclose)

          ↓      

System Call Layer - Unbuffered I/O  

  (open, read, write, close)

          ↓ 

Kernel

          ↓

Hardware
```



### struct _IO_FILE
기본이되는 _IO_FILE 구조체의 구조를 살펴보자.

libio/bits/types/struct_FILE.h 에 정의되어있는걸 보자.

```c
struct _IO_FILE
{
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */

  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;	/* Current read pointer */
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */

  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2:24;
  /* Fallback buffer to use when malloc fails to allocate one.  */
  char _short_backupbuf[1];
  __off_t _old_offset; /* This used to be _offset but it's too small.  */

  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
```

C++ streambuf protocol을 위한것이라는 말이 있는데 stdout,stdin의 버퍼와 관련이 있다는것을 알수있다.

버퍼링에는 3가지모드가있다.


-Line buffered - \n을 만나면 flush , stdin,stdout 기본 모드

-Fully buffered - 버퍼가 가득차면 flush되고 파일 입출력 기본 모드.

-unbufferd - 즉시 시스템콜을하고 stderr의 기본모드.


FSOP 공격은 기본적으로 _IO_FILE의 구조체 , 후에 나올 vtable , glibc 2.24버전 이상에서 새로 추가된
vtable검증 우회를 위한 _IO_strfile 등을 조작해서 공격을 수행한다.


FILE구조체는 _chain 필드를 통해 서로 연결되어 연결 리스트(전역변수 _IO_list_all로 정의)를 형성하는데 이 값을 통해 모든 FILE 구조체를 탐색할수있다.


프로세스는 시작시에 자동으로 stdin(_IO_2_1_stdin_),stdout(_IO_2_1_stdout_),stderr
(_IO_2_1_stderr_) 3개의 FILE스트림을 libc.so의 데이터 영역에 미리 할당된 전역변수로 생성하고 fopen등으로 생성한 파일 스트림은 동적할당으로 힙 메모리에 할당된다.


실제 _IO_2_1_stdout_등의 구조를 보면 _IO_FILE 구조체와 IO_jump_t *vtable을 포함하는 _IO_FILE_plus구조체로 구성되어있다.


```c
/* We always allocate an extra word following an _IO_FILE.
   This contains a pointer to the function jump table used.
   This is for compatibility with C++ streambuf; the word can
   be used to smash to a pointer to a virtual function table. */

struct _IO_FILE_plus
{
  FILE file;
  const struct _IO_jump_t *vtable;
};

_IO_jumpt_t  
    ↓
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
};

```

실제 사용되는 _IO_2_1_stdout_ 의 *vtable에 사용되는_IO_jump_t로 정의된 _IO_file_jumps를 gdb로 살펴보자.

pwndbg> p (struct _IO_jump_t)_IO_file_jumps

```
{
  __dummy = 0,
  __dummy2 = 0,
  __finish = 0x7ffff7c91a40 <_IO_new_file_finish>,
  __overflow = 0x7ffff7c92df0 <_IO_new_file_overflow>,
  __underflow = 0x7ffff7c92640 <_IO_new_file_underflow>,
  __uflow = 0x7ffff7c955a0 <__GI__IO_default_uflow>,
  __pbackfail = 0x7ffff7c96de0 <__GI__IO_default_pbackfail>,
  __xsputn = 0x7ffff7c939e0 <_IO_new_file_xsputn>,
  __xsgetn = 0x7ffff7c93d20 <__GI__IO_file_xsgetn>,
  __seekoff = 0x7ffff7c93160 <_IO_new_file_seekoff>,
  __seekpos = 0x7ffff7c95cc0 <_IO_default_seekpos>,
  __setbuf = 0x7ffff7c92400 <_IO_new_file_setbuf>,
  __sync = 0x7ffff7c93010 <_IO_new_file_sync>,
  __doallocate = 0x7ffff7c85120 <__GI__IO_file_doallocate>,
  __read = 0x7ffff7c938b0 <__GI__IO_file_read>,
  __write = 0x7ffff7c93940 <_IO_new_file_write>,
  __seek = 0x7ffff7c938d0 <__GI__IO_file_seek>,
  __close = 0x7ffff7c93930 <__GI__IO_file_close>,
  __stat = 0x7ffff7c938e0 <__GI__IO_file_stat>,
  __showmanyc = 0x7ffff7c96f90 <_IO_default_showmanyc>,
  __imbue = 0x7ffff7c96fa0 <_IO_default_imbue>
}
```
이런식의 구조를 확인할수있다.


### FILE 스트림의 함수 호출 흐름


프로그램에서 stdout,stdin,stdrr등이 어떻게 작동하는지 알아보자.

puts함수를 살펴보면 아래와 같이 정의되어있다.

```c
// glibc/libio/ioputs.c

#include "libioP.h"
#include <string.h>
#include <limits.h>
int
_IO_puts (const char *str)
{
  int result = EOF;
  size_t len = strlen (str);
  _IO_acquire_lock (stdout);
  if ((_IO_vtable_offset (stdout) != 0
       || _IO_fwide (stdout, -1) == -1)
      && _IO_sputn (stdout, str, len) == len
      && _IO_putc_unlocked ('\n', stdout) != EOF)
    result = MIN (INT_MAX, len + 1);
  _IO_release_lock (stdout);
  return result;
}
weak_alias (_IO_puts, puts)
libc_hidden_def (_IO_puts)

```

여러 검증을하면서 _IO_sputn을 호출하는데 _IO_sputn은 _IO_XSPUTN()으로 재정의된다.

#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)

```c
/* The 'xsputn' hook writes upto N characters from buffer DATA.
   Returns EOF or the number of character actually written.
   It matches the streambuf::xsputn virtual function. */
typedef size_t (*_IO_xsputn_t) (FILE *FP, const void *DATA,
				    size_t N);
#define _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)

```

그리고 이 _IO_XSPUTN()은 정의된 각 FILE타입에 따라 vtable의 호출 함수들이 조금씩 바뀌는데 vtable을 참조해서 __xsputn 위치에 있는 함수 포인터를 호출한다.


glibc/libio/libioP.h.html에서 다른 여러 스트림들의 vtable들을 확인할수있다.

gdb에서 __io_vtables를 통해서도 확인가능하다.


위에서 gdb로 살펴본 구조체에서 __IO_2_1_stdout_ 스트림은 _IO_file_jumps_ vtable구조를 사용하는데 여기서 __xsputn위치에 해당하는 함수는 _IO_new_file_xsputn 이다.


```c

_IO_new_file_xsputn (FILE *f, const void *data, size_t n)
{
  const char *s = (const char *) data;
  size_t to_do = n;
  int must_flush = 0;
  size_t count = 0;
  if (n <= 0)
    return 0;
  /* This is an optimized implementation.
     If the amount to be written straddles a block boundary
     (or the filebuf is unbuffered), use sys_write directly. */
  /* First figure out how much space is available in the buffer. */
  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING)) //[A]
  {
    count = f->_IO_buf_end - f->_IO_write_ptr;
    if (count >= n)
	  {
	    const char *p;
	    for (p = s + n; p > s; )
	    {
	      if (*--p == '\n')
		    {
		      count = p - s + 1;
		      must_flush = 1;
		      break;
		    }
	    }
	  }
  }
  else if (f->_IO_write_end > f->_IO_write_ptr)
    count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */
  /* Then fill the buffer. */
  if (count > 0)
  {
    if (count > to_do)
	    count = to_do;
    f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);
    s += count;
    to_do -= count;
  }
  if (to_do + must_flush > 0)
    {
      size_t block_size, do_write;
      /* Next flush the (full) buffer. */
      if (_IO_OVERFLOW (f, EOF) == EOF)
	/* If nothing else has to be written we must not signal the
	   caller that everything has been written.  */
	return to_do == 0 ? EOF : n - to_do;
      /* Try to maintain alignment: write a whole number of blocks.  */
      block_size = f->_IO_buf_end - f->_IO_buf_base;
      do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);
      if (do_write)
	{
	  count = new_do_write (f, s, do_write);
	  to_do -= count;
	  if (count < do_write)
	    return n - to_do;
	}
      /* Now write out the remainder.  Normally, this will fit in the
	 buffer, but it's somewhat messier for line-buffered files,
	 so we let _IO_default_xsputn handle the general case. */
      if (to_do)
	to_do -= _IO_default_xsputn (f, s+do_write, to_do);
    }
  return n - to_do;
}
libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)

```

xsputn을 살펴보면 여러 검증을 거치면서 _IO_OVERFLOW(_IO_new_file_overflow),new_do_write등 함수들을 호출하고 여러 조건들을 검증하면서 최종적으로 시스템 콜을 호출한다.


간단하게 살펴보면 이런 흐름으로 시스템콜을 호출하는걸 알수있다. 추후에 문제를 풀면서 더 자세히 살펴보겠다.

기본적으로 write,read등 이런식으로 file구조체에서 vtable을 참조해 필요한 함수들을 호출하면서 시스템콜에 도달하게된다.


간단하게 요약하자면

puts => _IO_puts() => _IO_sputn => _IO_XSPUTN (*vtable -> __xsputn(_IO_new_file_xsputn())) => _IO_OVERFLOW => *vtable -> overflow(_IO_new_file_overflow) => _IO_new_do_write -> new_do_write -> SYSWRITE

이런식으로 호출이되게된다.


### FSOP공격의 핵심

FSOP은 이런식의 스트림이 vtable을 참조해서 함수 호출하는 방식을 공격하기위해 정교하게 _IO_FILE , vtable을 조작해서 vtable->__xsputn,__overflow등을 system으로 바꾸게되면 _IO_new_file_xsputn()이 아닌 system함수가 호출이 가능하다.

FSOP공격은 glibc 2.24버전 이전과 이후로 조금 달라지게되는데 glibc 2.24+ 버전부터 vtable이 믿을수있는 주소에서 호출이되는지 검증로직이 추가되어서 추후에 설명할 _IO_strfile 구조체를 추가 조작이 필요하다.


### 다음 글에서
실제 문제를 통해 file구조체와 vtable을 조작해서 leak부터 exploit까지 상세히 살펴보겠다.

